{
  "status": "ok",
  "draft_id": "draft_b651e12bb0",
  "process_code": "PROC_TOOLPACK_BOOTSTRAP",
  "process_name": "工具包生成工艺",
  "base_process_id": "procdef_059c32ad5616",
  "change_request": "{\"change_request\": \"工艺PROC_TOOLPACK_BOOTSTRAP已通过全部审计校验，本轮无需迭代调整\"}",
  "goal": "提升工艺文档质量与工具脚本完备度",
  "plan": {
    "auto_execute": false,
    "max_duration_sec": 30,
    "quality_threshold": 0.95,
    "priority": "normal",
    "steps": [
      "地图API采样",
      "LLM归并别名",
      "工具包脚本生成",
      "质量审计回放"
    ]
  },
  "process_doc_markdown": "# 工艺流程文档：工具包生成工艺（修改版）\n\n- **process_code**: `PROC_TOOLPACK_BOOTSTRAP`\n- **change_request**: {\"change_request\": \"工艺PROC_TOOLPACK_BOOTSTRAP已通过全部审计校验，本轮无需迭代调整\"}\n- **goal**: 提升工艺文档质量与工具脚本完备度\n- **auto_execute**: False\n\n## 修改步骤\n\n1. 地图API采样\n2. LLM归并别名\n3. 工具包脚本生成\n4. 质量审计回放\n\n## 配置信息\n\n| 配置项 | 值 |\n| ---- | ---- |\n| 执行优先级 | normal |\n| 最大执行时长 | 30s |\n| 质量阈值 | 0.95 |",
  "created_at": "2026-02-14T16:37:14.708046",
  "updated_at": "2026-02-14T16:37:14.708065",
  "compilation": {
    "success": true,
    "process_code": "PROCTO_V1",
    "process_spec": {
      "process_id": "procdef_088d05dd4aa1",
      "process_code": "PROCTO_V1",
      "process_name": "工具包生成",
      "domain": "address_governance",
      "version": "1.0.0",
      "version_id": "procver_a0837f16d496",
      "status": "draft",
      "created_at": "2026-02-14T16:37:14.710733",
      "steps": [
        {
          "step_index": 1,
          "name": "INPUT_VALIDATION",
          "description": "输入验证",
          "tool_name": "address_validator",
          "tool_module": "validators.py",
          "parameters": {
            "max_length": 200,
            "required_fields": [
              "address"
            ],
            "allowed_formats": [
              "standard",
              "simplified"
            ]
          }
        },
        {
          "step_index": 2,
          "name": "QUALITY_CHECK",
          "description": "质量评估",
          "tool_name": "quality_evaluator",
          "tool_module": "evaluators.py",
          "parameters": {
            "accuracy_threshold": 0.95,
            "completeness_threshold": 0.9,
            "consistency_threshold": 0.88
          }
        },
        {
          "step_index": 3,
          "name": "DATA_GENERATION",
          "description": "数据生成",
          "tool_name": "data_generator",
          "tool_module": "generators.py",
          "parameters": {
            "use_llm": true,
            "model": "gpt-3.5",
            "temperature": 0.7
          }
        },
        {
          "step_index": 4,
          "name": "OUTPUT_PERSIST",
          "description": "结果持久化",
          "tool_name": "db_persister",
          "tool_module": "persisters.py",
          "parameters": {
            "database": "sqlite",
            "table_name": "process_results",
            "batch_size": 1000
          }
        }
      ],
      "estimated_duration": 60,
      "required_workers": 1,
      "quality_rules": {
        "accuracy_threshold": 0.9,
        "completeness_threshold": 0.9,
        "consistency_threshold": 0.9
      },
      "resource_requirements": {
        "memory_gb": 2,
        "timeout_sec": 600,
        "retry_count": 3,
        "batch_size": 1000
      },
      "tools": [
        "address_validator",
        "quality_evaluator",
        "data_generator",
        "db_persister"
      ],
      "tool_scripts": {
        "address_validator": "\"\"\"\n地址验证器 - 自动生成\nDomain: address_governance\n参数: {'max_length': 200, 'required_fields': ['address'], 'allowed_formats': ['standard', 'simplified']}\n\"\"\"\n\nimport re\nfrom typing import Dict, List\n\n\nclass AddressValidator:\n    \"\"\"地址验证器\"\"\"\n\n    def __init__(self, **config):\n        self.max_length = config.get('max_length', 200)\n        self.required_fields = config.get('required_fields', ['address'])\n        self.allowed_formats = config.get('allowed_formats', ['standard'])\n\n    def validate(self, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"验证地址数据\"\"\"\n\n        errors = []\n        warnings = []\n\n        # 检查必填字段\n        for field in self.required_fields:\n            if field not in data or not data[field]:\n                errors.append(f'缺少必填字段: {field}')\n\n        if errors:\n            return {'valid': False, 'errors': errors, 'score': 0.0}\n\n        address = data.get('address', '').strip()\n\n        # 长度检查\n        if len(address) > self.max_length:\n            errors.append(f'地址长度 {len(address)} 超过限制 {self.max_length}')\n\n        if len(address) < 2:\n            errors.append('地址过短（最少2字符）')\n\n        # 字符检查\n        cn_chars = sum(1 for c in address if ord(c) >= 0x4e00 and ord(c) <= 0x9fff)\n        if cn_chars == 0:\n            warnings.append('地址中没有中文字符')\n\n        # 数字检查\n        has_numbers = any(c.isdigit() for c in address)\n        if not has_numbers:\n            warnings.append('地址中没有数字')\n\n        return {\n            'valid': len(errors) == 0,\n            'errors': errors,\n            'warnings': warnings,\n            'address': address,\n            'score': 1.0 - len(errors) * 0.5,\n            'metadata': {\n                'length': len(address),\n                'chinese_chars': cn_chars,\n                'has_numbers': has_numbers\n            }\n        }\n\n\ndef validate_address(address: str, **config) -> Dict[str, Any]:\n    \"\"\"快速验证函数\"\"\"\n    validator = AddressValidator(**config)\n    return validator.validate({'address': address})\n\n\nif __name__ == '__main__':\n    validator = AddressValidator()\n\n    test_cases = [\n        '北京市朝阳区建国门外大街1号',\n        '上海市浦东新区张江高科技园区科苑路88号',\n        '',\n        'Test Address'\n    ]\n\n    for addr in test_cases:\n        result = validate_address(addr)\n        print(f'{addr[:30]:30} → {result[\"valid\"]} ({result[\"score\"]:.2f}/1.0)')\n",
        "quality_evaluator": "\"\"\"\n质量评估器 - 自动生成\nDomain: address_governance\n参数: {'accuracy_threshold': 0.95, 'completeness_threshold': 0.9, 'consistency_threshold': 0.88}\n\"\"\"\n\ndef evaluate_quality(output: Dict[str, Any], **config) -> Dict[str, Any]:\n    \"\"\"\n    评估处理输出的质量\n\n    评估指标:\n    - accuracy: 准确率（0-1）\n    - completeness: 完整率（0-1）\n    - consistency: 一致性（0-1）\n    \"\"\"\n\n    accuracy = output.get('accuracy', 1.0)\n    completeness = output.get('completeness', 1.0)\n    consistency = output.get('consistency', 1.0)\n\n    # 加权评分\n    weights = config.get('weights', {'accuracy': 0.5, 'completeness': 0.3, 'consistency': 0.2})\n    overall_score = (\n        accuracy * weights['accuracy'] +\n        completeness * weights['completeness'] +\n        consistency * weights['consistency']\n    )\n\n    # 阈值检查\n    accuracy_threshold = config.get('accuracy_threshold', 0.95)\n    completeness_threshold = config.get('completeness_threshold', 0.9)\n    consistency_threshold = config.get('consistency_threshold', 0.88)\n\n    passed = (\n        accuracy >= accuracy_threshold and\n        completeness >= completeness_threshold and\n        consistency >= consistency_threshold\n    )\n\n    return {\n        'accuracy': accuracy,\n        'completeness': completeness,\n        'consistency': consistency,\n        'overall_score': overall_score,\n        'passed': passed,\n        'details': {\n            'accuracy_threshold': accuracy_threshold,\n            'completeness_threshold': completeness_threshold,\n            'consistency_threshold': consistency_threshold\n        }\n    }\n",
        "data_generator": "\"\"\"\n数据生成器 - 自动生成\nDomain: address_governance\n参数: {'use_llm': True, 'model': 'gpt-3.5', 'temperature': 0.7}\n\"\"\"\n\nfrom typing import Dict, Any\n\n\ndef generate_data(input_payload: Dict[str, Any], **config) -> Dict[str, Any]:\n    \"\"\"根据输入生成结构化数据。\n\n    说明：\n    - 默认返回规则生成结果\n    - 如接入外部 LLM，可在此函数中替换实现\n    \"\"\"\n\n    use_llm = bool(config.get(\"use_llm\", True))\n    model = str(config.get(\"model\", \"gpt-3.5\"))\n    temperature = float(config.get(\"temperature\", 0.7))\n\n    base = {\n        \"mode\": \"llm\" if use_llm else \"rule\",\n        \"model\": model,\n        \"temperature\": temperature,\n        \"input\": input_payload,\n    }\n\n    # 依赖外部推理服务：未配置时只返回能力状态，不伪造生成结果\n    base[\"generated\"] = {\n        \"status\": \"requires_external_generation_service\",\n        \"summary\": \"external generation service is required\",\n    }\n\n    return base\n",
        "db_persister": "\"\"\"\n数据库持久化器 - 自动生成\nDomain: address_governance\n参数: {'database': 'sqlite', 'table_name': 'process_results', 'batch_size': 1000}\n\"\"\"\n\nimport sqlite3\nimport json\nfrom typing import List, Dict, Any\n\n\nclass DBPersister:\n    \"\"\"数据库持久化器\"\"\"\n\n    def __init__(self, db_path: str = None, **config):\n        self.db_path = db_path or config.get('db_path', 'process_results.db')\n        self.table_name = config.get('table_name', 'process_results')\n        self.batch_size = config.get('batch_size', 1000)\n\n    def persist(self, records: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        持久化数据到数据库\n\n        Args:\n            records: 数据记录列表\n\n        Returns:\n            {\n                'success': bool,\n                'inserted': int,\n                'failed': int,\n                'errors': list\n            }\n        \"\"\"\n\n        inserted = 0\n        failed = 0\n        errors = []\n\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n\n            # 创建表（如果不存在）\n            self._create_table(cursor)\n\n            # 批量插入\n            for i in range(0, len(records), self.batch_size):\n                batch = records[i:i+self.batch_size]\n                try:\n                    for record in batch:\n                        self._insert_record(cursor, record)\n                    conn.commit()\n                    inserted += len(batch)\n                except Exception as e:\n                    errors.append(f'批次 {i//self.batch_size} 插入失败: {str(e)}')\n                    failed += len(batch)\n\n            conn.close()\n\n        except Exception as e:\n            errors.append(f'数据库操作错误: {str(e)}')\n            return {'success': False, 'inserted': 0, 'failed': len(records), 'errors': errors}\n\n        return {\n            'success': failed == 0,\n            'inserted': inserted,\n            'failed': failed,\n            'errors': errors\n        }\n\n    def _create_table(self, cursor):\n        \"\"\"创建表\"\"\"\n        create_sql = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {self.table_name} (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                data TEXT NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\"\n        cursor.execute(create_sql)\n\n    def _insert_record(self, cursor, record):\n        \"\"\"插入单条记录\"\"\"\n        data_json = json.dumps(record, ensure_ascii=False)\n        insert_sql = f\"INSERT INTO {self.table_name} (data) VALUES (?)\"\n        cursor.execute(insert_sql, (data_json,))\n\n\ndef persist_to_db(records: List[Dict[str, Any]], **config) -> Dict[str, Any]:\n    \"\"\"快速持久化函数\"\"\"\n    persister = DBPersister(**config)\n    return persister.persist(records)\n"
      },
      "goal": "提升工艺文档质量与工具脚本完备度",
      "description": "请在已有工艺 PROC_TOOLPACK_BOOTSTRAP (工具包生成工艺) 基础上完成如下变更：{\"change_request\": \"工艺PROC_TOOLPACK_BOOTSTRAP已通过全部审计校验，本轮无需迭代调整\"}"
    },
    "tool_scripts": {
      "address_validator": "\"\"\"\n地址验证器 - 自动生成\nDomain: address_governance\n参数: {'max_length': 200, 'required_fields': ['address'], 'allowed_formats': ['standard', 'simplified']}\n\"\"\"\n\nimport re\nfrom typing import Dict, List\n\n\nclass AddressValidator:\n    \"\"\"地址验证器\"\"\"\n\n    def __init__(self, **config):\n        self.max_length = config.get('max_length', 200)\n        self.required_fields = config.get('required_fields', ['address'])\n        self.allowed_formats = config.get('allowed_formats', ['standard'])\n\n    def validate(self, data: Dict[str, str]) -> Dict[str, Any]:\n        \"\"\"验证地址数据\"\"\"\n\n        errors = []\n        warnings = []\n\n        # 检查必填字段\n        for field in self.required_fields:\n            if field not in data or not data[field]:\n                errors.append(f'缺少必填字段: {field}')\n\n        if errors:\n            return {'valid': False, 'errors': errors, 'score': 0.0}\n\n        address = data.get('address', '').strip()\n\n        # 长度检查\n        if len(address) > self.max_length:\n            errors.append(f'地址长度 {len(address)} 超过限制 {self.max_length}')\n\n        if len(address) < 2:\n            errors.append('地址过短（最少2字符）')\n\n        # 字符检查\n        cn_chars = sum(1 for c in address if ord(c) >= 0x4e00 and ord(c) <= 0x9fff)\n        if cn_chars == 0:\n            warnings.append('地址中没有中文字符')\n\n        # 数字检查\n        has_numbers = any(c.isdigit() for c in address)\n        if not has_numbers:\n            warnings.append('地址中没有数字')\n\n        return {\n            'valid': len(errors) == 0,\n            'errors': errors,\n            'warnings': warnings,\n            'address': address,\n            'score': 1.0 - len(errors) * 0.5,\n            'metadata': {\n                'length': len(address),\n                'chinese_chars': cn_chars,\n                'has_numbers': has_numbers\n            }\n        }\n\n\ndef validate_address(address: str, **config) -> Dict[str, Any]:\n    \"\"\"快速验证函数\"\"\"\n    validator = AddressValidator(**config)\n    return validator.validate({'address': address})\n\n\nif __name__ == '__main__':\n    validator = AddressValidator()\n\n    test_cases = [\n        '北京市朝阳区建国门外大街1号',\n        '上海市浦东新区张江高科技园区科苑路88号',\n        '',\n        'Test Address'\n    ]\n\n    for addr in test_cases:\n        result = validate_address(addr)\n        print(f'{addr[:30]:30} → {result[\"valid\"]} ({result[\"score\"]:.2f}/1.0)')\n",
      "quality_evaluator": "\"\"\"\n质量评估器 - 自动生成\nDomain: address_governance\n参数: {'accuracy_threshold': 0.95, 'completeness_threshold': 0.9, 'consistency_threshold': 0.88}\n\"\"\"\n\ndef evaluate_quality(output: Dict[str, Any], **config) -> Dict[str, Any]:\n    \"\"\"\n    评估处理输出的质量\n\n    评估指标:\n    - accuracy: 准确率（0-1）\n    - completeness: 完整率（0-1）\n    - consistency: 一致性（0-1）\n    \"\"\"\n\n    accuracy = output.get('accuracy', 1.0)\n    completeness = output.get('completeness', 1.0)\n    consistency = output.get('consistency', 1.0)\n\n    # 加权评分\n    weights = config.get('weights', {'accuracy': 0.5, 'completeness': 0.3, 'consistency': 0.2})\n    overall_score = (\n        accuracy * weights['accuracy'] +\n        completeness * weights['completeness'] +\n        consistency * weights['consistency']\n    )\n\n    # 阈值检查\n    accuracy_threshold = config.get('accuracy_threshold', 0.95)\n    completeness_threshold = config.get('completeness_threshold', 0.9)\n    consistency_threshold = config.get('consistency_threshold', 0.88)\n\n    passed = (\n        accuracy >= accuracy_threshold and\n        completeness >= completeness_threshold and\n        consistency >= consistency_threshold\n    )\n\n    return {\n        'accuracy': accuracy,\n        'completeness': completeness,\n        'consistency': consistency,\n        'overall_score': overall_score,\n        'passed': passed,\n        'details': {\n            'accuracy_threshold': accuracy_threshold,\n            'completeness_threshold': completeness_threshold,\n            'consistency_threshold': consistency_threshold\n        }\n    }\n",
      "data_generator": "\"\"\"\n数据生成器 - 自动生成\nDomain: address_governance\n参数: {'use_llm': True, 'model': 'gpt-3.5', 'temperature': 0.7}\n\"\"\"\n\nfrom typing import Dict, Any\n\n\ndef generate_data(input_payload: Dict[str, Any], **config) -> Dict[str, Any]:\n    \"\"\"根据输入生成结构化数据。\n\n    说明：\n    - 默认返回规则生成结果\n    - 如接入外部 LLM，可在此函数中替换实现\n    \"\"\"\n\n    use_llm = bool(config.get(\"use_llm\", True))\n    model = str(config.get(\"model\", \"gpt-3.5\"))\n    temperature = float(config.get(\"temperature\", 0.7))\n\n    base = {\n        \"mode\": \"llm\" if use_llm else \"rule\",\n        \"model\": model,\n        \"temperature\": temperature,\n        \"input\": input_payload,\n    }\n\n    # 依赖外部推理服务：未配置时只返回能力状态，不伪造生成结果\n    base[\"generated\"] = {\n        \"status\": \"requires_external_generation_service\",\n        \"summary\": \"external generation service is required\",\n    }\n\n    return base\n",
      "db_persister": "\"\"\"\n数据库持久化器 - 自动生成\nDomain: address_governance\n参数: {'database': 'sqlite', 'table_name': 'process_results', 'batch_size': 1000}\n\"\"\"\n\nimport sqlite3\nimport json\nfrom typing import List, Dict, Any\n\n\nclass DBPersister:\n    \"\"\"数据库持久化器\"\"\"\n\n    def __init__(self, db_path: str = None, **config):\n        self.db_path = db_path or config.get('db_path', 'process_results.db')\n        self.table_name = config.get('table_name', 'process_results')\n        self.batch_size = config.get('batch_size', 1000)\n\n    def persist(self, records: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"\n        持久化数据到数据库\n\n        Args:\n            records: 数据记录列表\n\n        Returns:\n            {\n                'success': bool,\n                'inserted': int,\n                'failed': int,\n                'errors': list\n            }\n        \"\"\"\n\n        inserted = 0\n        failed = 0\n        errors = []\n\n        try:\n            conn = sqlite3.connect(self.db_path)\n            cursor = conn.cursor()\n\n            # 创建表（如果不存在）\n            self._create_table(cursor)\n\n            # 批量插入\n            for i in range(0, len(records), self.batch_size):\n                batch = records[i:i+self.batch_size]\n                try:\n                    for record in batch:\n                        self._insert_record(cursor, record)\n                    conn.commit()\n                    inserted += len(batch)\n                except Exception as e:\n                    errors.append(f'批次 {i//self.batch_size} 插入失败: {str(e)}')\n                    failed += len(batch)\n\n            conn.close()\n\n        except Exception as e:\n            errors.append(f'数据库操作错误: {str(e)}')\n            return {'success': False, 'inserted': 0, 'failed': len(records), 'errors': errors}\n\n        return {\n            'success': failed == 0,\n            'inserted': inserted,\n            'failed': failed,\n            'errors': errors\n        }\n\n    def _create_table(self, cursor):\n        \"\"\"创建表\"\"\"\n        create_sql = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {self.table_name} (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                data TEXT NOT NULL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        \"\"\"\n        cursor.execute(create_sql)\n\n    def _insert_record(self, cursor, record):\n        \"\"\"插入单条记录\"\"\"\n        data_json = json.dumps(record, ensure_ascii=False)\n        insert_sql = f\"INSERT INTO {self.table_name} (data) VALUES (?)\"\n        cursor.execute(insert_sql, (data_json,))\n\n\ndef persist_to_db(records: List[Dict[str, Any]], **config) -> Dict[str, Any]:\n    \"\"\"快速持久化函数\"\"\"\n    persister = DBPersister(**config)\n    return persister.persist(records)\n"
    },
    "tool_metadata": [
      {
        "tool_name": "address_validator",
        "step": "INPUT_VALIDATION",
        "status": "generated",
        "file_path": "tools/generated_tools/validators/address_validator.py"
      },
      {
        "tool_name": "quality_evaluator",
        "step": "QUALITY_CHECK",
        "status": "generated",
        "file_path": "tools/generated_tools/evaluators/quality_evaluator.py"
      },
      {
        "tool_name": "data_generator",
        "step": "DATA_GENERATION",
        "status": "generated",
        "file_path": "tools/generated_tools/generators/data_generator.py"
      },
      {
        "tool_name": "db_persister",
        "step": "OUTPUT_PERSIST",
        "status": "generated",
        "file_path": "tools/generated_tools/persisters/db_persister.py"
      }
    ],
    "validation_errors": [],
    "validation_warnings": []
  }
}
